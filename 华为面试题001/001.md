# 一
说说你对IOC的理解？

## 我的回答：

简单点来说，IOC就是一个map,键值为类名或者是class,这就涉及到了我们的IOC获取对象的方式：根据名字来获取和根据类型来获取。IOC是Spring中控制反转思想的集中体现，它帮助我们管理java对象，一般情况下，spring会扫描所有带有@component主键的类，并把他们存放在IoC的map中，同样的任何标记有@resource或@autuow主键的对象，会被IOC通过反射生成一个对象注入其中，完成属性注入。此外呢，IOC还有一个三层缓存的机制，用来解决循环依赖问题，关于循环依赖，指的是，一个beanA依赖于另一个beanB,而beanB又依赖于beanA这种问题。ioc是这样解决的，主要是涉及了三个map,分别存放，java对象的工厂bean,java对象的初始化bean,java对象的完全实例化的bean.beana进行属性注入的时候，发现不存在beanB,于是就把当前beanA的工厂类存放进map,并开始BeanB的示例化，BeanB的属性注入，会把BeanA的工厂类存放入beanB，完成beanB的初始化，并将其放入二级map,然后回到beanA的属性注入中，将初始化的beanB，注入其中，完成了对beanA的实例化，然后又完成了beanB的实例化，解决了循环依赖问题。

## 标准答案

### 什么是IOC？
IOC（Inversion of Control，控制反转）是一种设计思想，它将对象的创建和管理权从代码本身转移到外部容器（如Spring容器），从而降低代码间的耦合度。在传统的编程模式下，对象通常自己创建其依赖的对象；而在IOC模式下，对象不再负责创建自己的依赖，而是由外部容器负责注入。

### IOC的核心概念
- **控制反转**：对象的创建、配置和生命周期管理不再由对象自身控制，而是由外部容器来管理
- **依赖注入（DI）**：IOC的一种实现方式，通过构造函数、setter方法或字段注入等方式将依赖项传递给对象

### IOC的实现原理
- Spring容器在启动时会读取配置元数据（XML配置、注解或Java配置类）
- 根据配置信息创建和组装Bean对象
- 将Bean对象放入容器中进行统一管理
- 在需要使用时，通过依赖注入的方式将Bean注入到其他对象中

### IOC容器中的Bean管理
- Bean的定义：通过@Component、[@Service](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L4)、[@Repository](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L4)、[@Controller](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L4)等注解标识组件
- Bean的依赖注入：通过[@Autowired](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L4)、[@Resource](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L4)等注解完成依赖注入
- Bean的生命周期管理：包括实例化、属性设置、初始化回调、使用和销毁等阶段

### IOC的三级缓存机制
Spring使用三级缓存来解决循环依赖问题：
- singletonObjects：一级缓存，存放完全初始化好的单例Bean
- earlySingletonObjects：二级缓存，存放早期暴露的Bean（已实例化但未完成属性填充和初始化）
- singletonFactories：三级缓存，存放Bean工厂，用于处理代理对象的情况

### IOC的优势
- **降低耦合性**：对象之间不再直接依赖，而是通过接口进行松耦合连接
- **提高可测试性**：更容易进行单元测试，可以方便地替换依赖项
- **提高可维护性**：修改依赖关系不需要修改代码，只需修改配置
- **集中管理**：容器统一管理对象的生命周期和依赖关系

# 说说你对AOP的理解。

## 我的回答：
AOP，是一种切面编程，在spring中，主要用于安全，日志等方面的处理。在spring中的使用，主要是，通过@ASPECT定义一个切面类，然后通过point定义切断，最后通过@Around、@before等注解完成对于方法的处理。切面编程是一种动态代理的思想，spring通过为被代理的bean生成代理对象，并在其中添加我们的切面方法，一达到我们预期的效果。

## 标准答案

### 什么是AOP？
AOP（Aspect Oriented Programming，面向切面编程）是OOP的补充和延伸，它将散布在系统各处的通用功能（如日志记录、事务管理、安全检查等）从业务逻辑中分离出来，形成独立的模块，避免代码重复，提升系统的可维护性。

### AOP的核心概念
- **切面（Aspect）**：一个关注点的模块化，通常是一个类，使用[@Aspect](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L44)注解标识
- **连接点（Join Point）**：程序执行过程中某个特定的点，如方法调用或异常抛出
- **切入点（Pointcut）**：匹配连接点的断言，决定了哪些连接点会被拦截，使用[@Pointcut](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L44)注解定义
- **通知（Advice）**：切面在特定连接点上执行的动作
  - 前置通知（[@Before](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L44)）：在方法执行前运行
  - 后置通知（[@After](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L44)）：无论方法是否成功执行都会运行
  - 返回通知（[@AfterReturning](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L44)）：方法正常返回后运行
  - 异常通知（[@AfterThrowing](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L44)）：方法抛出异常时运行
  - 环绕通知（[@Around](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L44)）：包围连接点，可以在方法执行前后做操作
- **目标对象（Target Object）**：被一个或多个切面通知的对象
- **织入（Weaving）**：将切面应用到目标对象的过程

### AOP的实现原理
Spring AOP主要基于动态代理实现：
- **JDK动态代理**：当目标对象实现了接口时，Spring默认使用JDK动态代理创建代理对象，通过[InvocationHandler](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L44)接口实现代理
- **CGLIB代理**：当目标对象没有实现接口时，Spring使用CGLIB库生成目标类的子类作为代理对象

### AOP的应用场景
- 日志记录：记录方法的调用情况和参数信息
- 性能监控：统计方法执行时间
- 安全控制：方法调用前进行权限验证
- 事务管理：声明式事务处理
- 缓存：方法结果缓存

### AOP的优缺点
- **优点**：减少重复代码，提高代码复用性；增强系统的可维护性；实现关注点分离
- **缺点**：增加了系统的复杂性；可能影响程序性能；调试困难

### 注意事项
- AOP只对Spring容器管理的Bean有效
- 同一类内部的方法调用不会触发AOP通知
- 使用CGLIB代理时，目标类不能是final类，方法不能是final方法


# JDK动态代理是什么？和cglib区别？

## 我的回答：

JDK动态代理是指，在java中，java通过接口，通过反射实现了实现了该接口的类，一般用于安全、日志等方面，起到了解耦的作用。和CGlib相比，java动态代理是针对接口进行的，cglib是针对类进行代理的。cglib在后来渐渐被废弃了，现在主流的是jdk动态代理

## 标准答案

### JDK动态代理
JDK动态代理是Java提供的一种动态创建代理对象的机制，它利用[java.lang.reflect.Proxy](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L89)类和[InvocationHandler](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L89)接口来实现。它要求被代理的目标对象必须实现至少一个接口，代理器会在运行时动态创建一个实现了目标对象相同接口的新类。

#### 实现原理：
- 通过[Proxy](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L89)类的[newProxyInstance](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L89)方法创建代理对象
- [InvocationHandler](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L89)接口的[invoke](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L89)方法拦截所有方法调用
- 生成的代理类继承自Proxy并实现了目标对象的所有接口

### CGLIB动态代理
CGLIB（Code Generation Library）是一个强大的高性能代码生成库，它可以在运行时动态扩展Java类和实现Java接口。CGLIB通过继承的方式创建代理对象，为目标类生成一个子类，并在子类中拦截父类方法的调用来实现AOP功能。

#### 实现原理：
- 通过ASM字节码生成框架生成被代理类的子类
- 重写父类的方法，在方法调用前后插入额外逻辑
- 使用MethodInterceptor接口拦截方法调用

### JDK动态代理与CGLIB的区别

| 特性 | JDK动态代理 | CGLIB动态代理 |
|------|-------------|---------------|
| 实现机制 | 基于接口 | 基于继承 |
| 目标对象要求 | 必须实现接口 | 不需要实现接口 |
| 生成对象类型 | 实现了目标对象接口的类 | 目标类的子类 |
| 性能 | 较快，JDK内置支持 | 生成较慢，但运行期性能较好 |
| 限制 | 无法代理无接口的类 | 无法代理final类和final方法 |

### Spring中的选择策略
Spring AOP会根据目标对象是否实现接口自动选择代理方式：
- 如果目标对象实现了接口，则默认使用JDK动态代理
- 如果目标对象没有实现接口，则使用CGLIB
- 可以通过配置强制使用CGLIB（proxy-target-class="true"）

### 注意事项
- CGLIB并未被废弃，仍在Spring等框架中广泛使用
- CGLIB代理基于继承，所以不能代理final类和final修饰的方法
- JDK动态代理基于接口，只能拦截接口中定义的方法


# 如何评估 / 判断索引是否生效？常见索引失效场景有哪些？ 

## 我的回答：50
在mysql中，我们可以通过explain对sql语句进行测试，不难发现它是否走了索引。
索引失效的情况主要有，sql查询没有遵循最左匹配原则，没有按照索引的顺序在where添加限制条件。或者，在sellect查询数据的时候，以*代替所有数据，这会使mysql直接进行回表查询，不会走索引。

## 标准答案

### 如何评估/判断索引是否生效？

#### 1. 使用EXPLAIN命令分析SQL执行计划
- 查看[type](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L141)字段：ALL表示全表扫描，index表示索引扫描，ref表示非唯一索引查找等
- 查看[key](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L141)字段：显示使用的索引名称，NULL表示未使用索引
- 查看[key_len](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L141)字段：表示索引中使用的字节数，可以判断索引的使用情况
- 查看[rows](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L141)字段：估算需要扫描的行数，越小越好
- 查看[Extra](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L141)字段：包含Using index表示覆盖索引，Using where表示需要回表查询等

#### 2. 使用SHOW PROFILE查看执行时间
- 启用profiling: SET profiling = 1;
- 执行SQL后查看性能分析: SHOW PROFILES;

#### 3. 观察执行时间变化
- 对比索引建立前后SQL的执行时间

### 常见索引失效场景

#### 1. 违反最左前缀法则
- 对于复合索引，如果不使用最左侧的列进行查询，会导致索引失效
- 示例：索引(a,b,c)，查询条件where b='xxx' and c='xxx'，不包含a，索引失效

#### 2. 在索引列上进行计算或函数操作
- select * from table where year(date_col) = 2020;  -- 索引失效
- 正确做法：select * from table where date_col >= '2020-01-01' and date_col < '2021-01-01';

#### 3. 使用LIKE '%xxx%'进行模糊查询
- LIKE '%abc' 或 LIKE '%abc%' 会导致索引失效
- LIKE 'abc%' 可以正常使用索引（前缀匹配）

#### 4. 索引列使用OR连接
- select * from table where a = 1 or b = 2;  -- 如果a和b都有单独索引，可能导致索引失效
- 正确做法：为a和b创建复合索引，或使用UNION合并查询

#### 5. 类型隐式转换
- 索引列为字符串类型，查询值为数字但未加引号
- 例如：id为varchar类型，查询where id = 12345，发生类型转换导致索引失效

#### 6. 使用不等于(!= 或 <>)操作符
- where column != 'value' 通常不会使用索引

#### 7. IS NULL 和 IS NOT NULL
- IS NULL 可能使用索引，但 IS NOT NULL 通常不会使用索引

#### 8. 在索引列上使用NOT、!=、<>等否定操作符
- where status != 'active' 通常不会使用索引
- 建议改为：where status = 'inactive'

#### 9. 查询条件过多使用复合索引的部分字段
- 复合索引(a,b,c)，只查询a,c，跳过了b，可能导致索引失效

### 重要说明
- SELECT * 不会直接导致索引失效，索引是否使用取决于WHERE条件和执行计划
- 回表查询是由于非覆盖索引需要回主键索引获取数据，与是否使用*号无关
- 应通过[EXPLAIN](file:///c%3A/Users/27050/Desktop/java%E5%85%AB%E8%82%A1%E6%96%87%E6%80%BB%E7%BB%93/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98001/001.md#L132)分析执行计划来准确判断索引使用情况
