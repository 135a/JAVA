# 如何创建线程池？线程池常见参数有哪些？

## 我的回答 6分

JAVA中创建线程池的方法主要有
通过EXECTORPOOL接口，具体有以下几种线程池:
单线程池
固定线程池
定时线程池
等等

参数主要有：核心线程数（无论何时，线程池中至少保有的线程数）、最大线程数（线程池能够接收的最大线程数），线程等待队列（线程等待的队列），（异常处理策略）

## 标准答案:

创建线程池的方法：Exectors类和ThreadPoolExector类
Exectors主要有以下几种线程池：
1.单线程池
2.固定线程池
3.定时线程池
4.可缓存线程池
5.工作窃取线程池

核心参数主要有：
1.核心线程数（无论何时，线程池中至少保有的线程数）
2.最大线程数（线程池能够接收的最大线程数）
3.非核心线程数超时时间
4.时间单位
5.工作队列（用于缓存已提交但还没有执行的阻塞队列）
6.拒绝策略{
    1.默认策略：失败抛出异常
    2.既不丢失任务也不抛出异常
    3.丢弃策略，静悄悄丢弃，不抛出异常
    4.丢弃最老的策略，丢弃最老的，不抛出异常
}

# 请你说说HashMap底层原理和扩容机制

## 我的回答  75分
HashMap的底层原理，在java1.8以前，hashmap由数组和链表组成，在java1.8以后，由数组和链表和红黑树组成。默认大小为16，一旦数组长度大于8，节点大于64，就会变成红黑树。节点数大于容量的0.75时就会扩容，扩容为原来的二倍

## 标准答案:
hashmap的底层，java1.8以前，hashmap由数组和链表组成，java1.8之后，由数组、链表和红黑树组成，初始容量位16，负载因子位0.75，即，元素数量大于容量的0.75时就会扩容，扩容位原来的2倍。当数组长度大于64，链表长度大于8时，链表就会转变位红黑树。java1.7使用尾插法，java1.8使用头差法，避免了线程循环问题

# 说说JVM的垃圾回收算法。
 ## 我的回答 60
 JAVM主要有复制清除、整理清除、标记清除这三种垃圾回收算法。其中复制算法主要用于新生代中，每一次进行垃圾回收，把伊甸区和其中一个生存区的存活对象复制到另一个生存区，然后把剩余的不存活对象清除，已从root跟触发是否有路径到对象判断对象是否存活的依据。整理清除算法主要用于单线程情况，主要用于佬年代，每异常进行垃圾回收，把不存活的对象起到那个到堆内存的一侧，然后进行清除。至于标记清除算法，主要用于多线程情况，同样是老年代，对不存活的对象进行标记，然后把倍1标记的对象进行清除。
## 标准答案

### 复制算法

每次进行垃圾回收时，将伊甸区和其中1一个生存区的所有存活对象赋值到另一个生存区，然后清除伊甸区和该生存区的空间。主要用于新生代。
优点：算法简单，效率高
缺点：生存区腾出生存区的一般空间，空间利用率低，当存在大对象时，复制成本较高

### 整理清除算法

每次进行垃圾回收时，将所有的存储对象移动到堆的一端，清除剩余空间。主要用于老年代。
优点：不需要二外的内存空间
缺点：需要移动对象，效率低

### 标记清除算法，进行垃圾祸首时，堆死去的对象进行标记，然后进行清除。主要用于老年代
优点：不会产生内存碎片，不需要额外的内存空间
缺点：易产生内存碎片，可能导致难以存储大对象

### 可达性分析算法 从root gc 出发如果存在到底指定对象的路径，则该对象存活，否则不存活。

# 详细的说说Redis的数据类型

## 我的回答 60
Redis的主要的数据类型有：字符串、哈希、列表、快表，集合，有序集合
字符串，主要有sds组成，可更高效地利于鵆空间，自增自减等操作，适合用于点赞之类的原子性操作，除此之外，字符串还可以用于实现分布式锁，根据键是否存在来判断锁的状态
哈希，主要由压缩列表和哈希表组成，当数据较小时，会采用压缩列表，否则采用哈希表

列表，主要是压缩列表构成，可以用来实现队列等操作

集合，主要由压缩列表和interger组成，数据过大时会变成Interger,适用于求共同好友等场景

有序集合，主要是压缩列表和跳跃表组成，可以对数据通过分数进行排序


## 标准答案
Redis的数据类型主要包含字符串、哈希、列表、集合、有序集合。

字符串：主要由SDS组成，可以用于实现分布式锁，其自增自减等操作适用于点赞、计数器等原子性操作

哈希：主要由压缩列表和哈希表组成，当数据较小则用压缩列表，否则哈希表

列表：主要是压缩列表和双端队列组成，可用来实现消息队列等数据结构

集合，主要由interger和哈希表组成，数据过大选择哈希表 用于朋友圈求共同好友等场景

有序集合，主要是压缩列表和跳跃表组成，可以通过分数对就进行排序，用于分数排行榜等场景

# 说说Redis的持久化策略。

## 我的回答 3!!!

redis主要有AOF和RDB两种持久化策略，AOF是通过快照的方式，记录redis的完整数据，启动较快，但是redis是每隔一段时间保存一次快照，因此可能在时间间隔里会发生时间丢失的情况
RDB是通过增量日志的方式，记录RDB的写操作，恢复数据时，通过一条一条的写操作恢复数据，启动慢，体积大，但避免了数据丢失的问题。

第三种方法是，两者兼顾，在AOF快照的基础上，通过RDB记录写操作，可以起到很好的效果。

## 标准答案

把RDB和AOF颠倒即可


# Redis如何与数据库保持双写一致性

## 我的回答

想不起来了

## 标准答案

## 旁路缓存策略

如果是读请求，直接从redis中查找，如果没命中，则从数据库中查找，并写入redis中。
如果是写请求，首先写入数据库，然后更新redis。
适合读多写少的场景

## 延迟双删策略，

在写入数据前首先删除redis中的对应数据，然后更新数据库，隔一段时间再删除redis数据
和互斥锁搭配，适合高并发场景

## 消息队列

在执行写操作时，先将数据写入数据库，一旦成功，就通过消息队列返回成功的命令，消费者收到成功命令后，就开始删除redis的缓存。异步解耦场景

## 分布式锁控制

在写操作时，首先获取redsi的分布式锁，获取以后再对数据库数据进行修改，修改成功和删除缓存。串行化策略，避免并发冲突
高并发，强一致性场景

## TCC 模式
Try阶段，预留资源，如冻结账户余额

Comfirm阶段，确认账户金额，实行扣减

Cancel,回滚操作，释放预留资源

适合金融等原子性操作场景



