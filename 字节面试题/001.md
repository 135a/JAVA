# 如何创建线程池？线程池常见参数有哪些？

## 我的回答 6分

JAVA中创建线程池的方法主要有
通过EXECTORPOOL接口，具体有以下几种线程池:
单线程池
固定线程池
定时线程池
等等

参数主要有：核心线程数（无论何时，线程池中至少保有的线程数）、最大线程数（线程池能够接收的最大线程数），线程等待队列（线程等待的队列），（异常处理策略）

## 标准答案:

创建线程池的方法：Exectors类和ThreadPoolExector类
Exectors主要有以下几种线程池：
1.单线程池
2.固定线程池
3.定时线程池
4.可缓存线程池
5.工作窃取线程池

核心参数主要有：
1.核心线程数（无论何时，线程池中至少保有的线程数）
2.最大线程数（线程池能够接收的最大线程数）
3.非核心线程数超时时间
4.时间单位
5.工作队列（用于缓存已提交但还没有执行的阻塞队列）
6.拒绝策略{
    1.默认策略：失败抛出异常
    2.既不丢失任务也不抛出异常
    3.丢弃策略，静悄悄丢弃，不抛出异常
    4.丢弃最老的策略，丢弃最老的，不抛出异常
}

# 请你说说HashMap底层原理和扩容机制

## 我的回答  75分
HashMap的底层原理，在java1.8以前，hashmap由数组和链表组成，在java1.8以后，由数组和链表和红黑树组成。默认大小为16，一旦数组长度大于8，节点大于64，就会变成红黑树。节点数大于容量的0.75时就会扩容，扩容为原来的二倍

## 标准答案:
hashmap的底层，java1.8以前，hashmap由数组和链表组成，java1.8之后，由数组、链表和红黑树组成，初始容量位16，负载因子位0.75，即，元素数量大于容量的0.75时就会扩容，扩容位原来的2倍。当数组长度大于64，链表长度大于8时，链表就会转变位红黑树。java1.7使用尾插法，java1.8使用头差法，避免了线程循环问题

# 说说JVM的垃圾回收算法。
 ## 我的回答 60
 JAVM主要有复制清除、整理清除、标记清除这三种垃圾回收算法。其中复制算法主要用于新生代中，每一次进行垃圾回收，把伊甸区和其中一个生存区的存活对象复制到另一个生存区，然后把剩余的不存活对象清除，已从root跟触发是否有路径到对象判断对象是否存活的依据。整理清除算法主要用于单线程情况，主要用于佬年代，每异常进行垃圾回收，把不存活的对象起到那个到堆内存的一侧，然后进行清除。至于标记清除算法，主要用于多线程情况，同样是老年代，对不存活的对象进行标记，然后把倍1标记的对象进行清除。
## 标准答案

### 复制算法

每次进行垃圾回收时，将伊甸区和其中1一个生存区的所有存活对象赋值到另一个生存区，然后清除伊甸区和该生存区的空间。主要用于新生代。
优点：算法简单，效率高
缺点：生存区腾出生存区的一般空间，空间利用率低，当存在大对象时，复制成本较高

### 整理清除算法

每次进行垃圾回收时，将所有的存储对象移动到堆的一端，清除剩余空间。主要用于老年代。
优点：不需要二外的内存空间
缺点：需要移动对象，效率低

### 标记清除算法，进行垃圾祸首时，堆死去的对象进行标记，然后进行清除。主要用于老年代
优点：不会产生内存碎片，不需要额外的内存空间
缺点：易产生内存碎片，可能导致难以存储大对象

### 可达性分析算法 从root gc 出发如果存在到底指定对象的路径，则该对象存活，否则不存活。

# 详细的说说Redis的数据类型

## 我的回答 60
Redis的主要的数据类型有：字符串、哈希、列表、快表，集合，有序集合
字符串，主要有sds组成，可更高效地利于鵆空间，自增自减等操作，适合用于点赞之类的原子性操作，除此之外，字符串还可以用于实现分布式锁，根据键是否存在来判断锁的状态
哈希，主要由压缩列表和哈希表组成，当数据较小时，会采用压缩列表，否则采用哈希表

列表，主要是压缩列表构成，可以用来实现队列等操作

集合，主要由压缩列表和interger组成，数据过大时会变成Interger,适用于求共同好友等场景

有序集合，主要是压缩列表和跳跃表组成，可以对数据通过分数进行排序


## 标准答案
Redis的数据类型主要包含字符串、哈希、列表、集合、有序集合。

字符串：主要由SDS组成，可以用于实现分布式锁，其自增自减等操作适用于点赞、计数器等原子性操作

哈希：主要由压缩列表和哈希表组成，当数据较小则用压缩列表，否则哈希表

列表：主要是压缩列表和双端队列组成，可用来实现消息队列等数据结构

集合，主要由interger和哈希表组成，数据过大选择哈希表 用于朋友圈求共同好友等场景

有序集合，主要是压缩列表和跳跃表组成，可以通过分数对就进行排序，用于分数排行榜等场景

# 说说Redis的持久化策略。

## 我的回答 3!!!

redis主要有AOF和RDB两种持久化策略，AOF是通过快照的方式，记录redis的完整数据，启动较快，但是redis是每隔一段时间保存一次快照，因此可能在时间间隔里会发生时间丢失的情况
RDB是通过增量日志的方式，记录RDB的写操作，恢复数据时，通过一条一条的写操作恢复数据，启动慢，体积大，但避免了数据丢失的问题。

第三种方法是，两者兼顾，在AOF快照的基础上，通过RDB记录写操作，可以起到很好的效果。

## 标准答案

把RDB和AOF颠倒即可


# Redis如何与数据库保持双写一致性

## 我的回答

想不起来了

## 标准答案

## 旁路缓存策略

如果是读请求，直接从redis中查找，如果没命中，则从数据库中查找，并写入redis中。
如果是写请求，首先写入数据库，然后更新redis。
适合读多写少的场景

## 延迟双删策略，

在写入数据前首先删除redis中的对应数据，然后更新数据库，隔一段时间再删除redis数据
和互斥锁搭配，适合高并发场景

## 消息队列

在执行写操作时，先将数据写入数据库，一旦成功，就通过消息队列返回成功的命令，消费者收到成功命令后，就开始删除redis的缓存。异步解耦场景

## 分布式锁控制

在写操作时，首先获取redsi的分布式锁，获取以后再对数据库数据进行修改，修改成功和删除缓存。串行化策略，避免并发冲突
高并发，强一致性场景

## TCC 模式
Try阶段，预留资源，如冻结账户余额

Comfirm阶段，确认账户金额，实行扣减

Cancel,回滚操作，释放预留资源

适合金融等原子性操作场景

# 从「敲下一个 URL」到「页面出现在屏幕」整条链路全景

## 我的回答  2分

敲下一个url链接以后，url链接会被通过tcp发送到dns即域名服务器解析为ip地址并将相应的参数发生到ip地址指定的服务器上，服务器作出响应，通过tcp协议返回url所需要的前端页面以及相关数据，最后渲染成我们所看到的页面。

## 标准答案

整个过程可以分为以下几个步骤：

### 1. URL解析
浏览器首先解析输入的URL，提取出协议（如http/https）、域名、端口、路径等信息。

### 2. DNS域名解析
浏览器会依次查询：浏览器缓存 → 操作系统缓存 → hosts文件。如果这些地方都没有找到对应的IP地址，浏览器会向本地DNS服务器发送UDP请求查询域名对应的IP地址。如果本地DNS服务器没有该域名的记录，它会递归向上级DNS服务器查询，直到获取该URL对应的IP地址。

### 3. 建立TCP连接
获取到服务器IP地址后，浏览器与服务器建立TCP连接（三次握手）。如果是HTTPS协议，还需要进行TLS握手建立安全连接。

### 4. 发送HTTP请求
连接建立后，浏览器向服务器发送HTTP请求，包括请求方法、请求头、请求体等信息。

### 5. 服务器处理请求并响应
服务器接收到请求后，根据路由规则和业务逻辑处理请求，生成HTTP响应，包括状态码、响应头和响应体。

### 6. 浏览器接收响应并断开连接
浏览器接收服务器返回的数据，随后断开TCP连接（四次挥手）。

### 7. 页面渲染
浏览器开始对收到的HTML文档进行解析：
- 构建DOM树：解析HTML标签构建DOM节点树
- 构建CSSOM树：解析CSS样式构建CSS对象模型
- 生成渲染树：合并DOM树和CSSOM树，去除不可见元素
- 布局（Layout）：计算每个可见元素在屏幕上的确切位置和大小
- 绘制（Paint）：将渲染树的每个节点转换为屏幕上的实际像素

通过以上步骤，最终呈现出精美网页。

# HTTP vs. HTTPS 有什么区别?

## 我的回答

一.http没有ssl套界层，https有ssl套接层，后者有数据加密服务，更加安全

## 标准答案

http是明文传输，https是加密传输

https添加了TLS协议，有SSL套接层保证安全

http端口是80，https端口是443

http的tcp连接是三次握手，https是添加了一次TLS握手

https需要通过CA颁发数字证书证明域名是可信的

# HTTPS 的「秘钥交换 + 证书校验」全流程

## 我的回答
不会

## 标准答案

### TLS握手完整流程

**1. Client Hello（客户端问候）**
- 客户端向服务端发送：
  - 支持的TLS版本列表
  - 支持的密码套件列表（加密算法组合）
  - 客户端随机数（Client Random）
  - 会话ID（用于会话恢复）
  - 支持的扩展信息（如SNI、ALPN等）

**2. Server Hello（服务端回应）**
- 服务端向客户端发送：
  - 选定的TLS版本
  - 选定的密码套件
  - 服务端随机数（Server Random）
  - 会话ID

**3. Certificate（证书交换）**
- 服务端发送数字证书链，包含：
  - 服务器域名
  - 证书有效期
  - **服务器公钥**（通常是RSA或ECDSA公钥） ← 这就是客户端用来加密预主密钥的公钥
  - CA签名信息
  - 证书颁发机构信息

**4. Server Key Exchange（可选）**
- 对于某些密钥交换算法（如DHE/ECDHE），服务端发送：
  - 临时DH参数或ECDH公钥
  - 数字签名（证明参数确实来自该服务器）

**5. Server Hello Done**
- 服务端告知客户端初始握手消息结束

**6. 客户端验证阶段**
- 客户端验证服务器证书：
  - 证书链验证（逐级向上验证CA签名）
  - 域名匹配检查（Subject Alternative Name或Common Name）
  - 证书有效期检查
  - 证书吊销状态检查（CRL或OCSP）

**7. Client Key Exchange**
- 客户端生成预主密钥（Pre-Master Secret）：

  **RSA密钥交换方式：**
  - 客户端随机生成48字节的预主密钥
  - **使用从服务器证书中提取的RSA公钥**加密这个预主密钥
  - 将加密后的预主密钥发送给服务器
  - 服务器用自己的RSA私钥解密得到预主密钥

  **ECDHE密钥交换方式：**
  - 基于服务器的ECDH公钥和客户端自己生成的ECDH私钥
  - 通过椭圆曲线Diffie-Hellman算法计算出共享密钥
  - 这个共享密钥就是预主密钥
  - 整个过程不需要加密传输，因为算法本身保证安全性

**8. 密钥生成**
- 双方使用相同的算法生成会话密钥：
  - **主密钥（Master Secret）= PRF(预主密钥, "master secret", ClientRandom + ServerRandom)**
  - 各种会话密钥 = PRF(主密钥, 标签, ClientRandom + ServerRandom)
  - 包括：客户端写MAC密钥、服务端写MAC密钥、客户端写加密密钥、服务端写加密密钥

**9. Change Cipher Spec**
- 客户端和服务端分别发送消息，表示后续通信将使用协商好的加密参数

**10. Finished消息**
- 双方发送加密的Finished消息验证握手完整性
- 包含之前所有握手消息的摘要，确保没有被篡改

### 两种密钥交换方式对比

| 特性 | RSA密钥交换 | ECDHE密钥交换 |
|------|-------------|---------------|
| **前向安全性** | ❌ 无（私钥泄露可解密历史通信） | ✅ 有（每次使用临时密钥） |
| **性能** | 较快（只需一次RSA加密） | 稍慢（需要椭圆曲线计算） |
| **安全性** | 依赖RSA私钥保护 | 提供完美前向保密 |
| **实现复杂度** | 简单 | 复杂 |

### 关键安全机制

**证书校验要点：**
- 信任链验证：从服务器证书到根CA的完整验证路径
- 域名绑定：确保证书适用于请求的域名
- 时间有效性：检查证书是否在有效期内
- 吊销检查：确认证书未被撤销

**前向安全性（Forward Secrecy）：**
- 使用ECDHE等临时密钥交换算法
- 即使长期私钥泄露，历史会话仍安全
- 每次连接使用不同的临时密钥对

**密钥派生函数（KDF）：**
- 使用伪随机函数PRF从主密钥派生各种会话密钥
- 确保不同用途的密钥相互独立
- 防止一个密钥泄露影响其他密钥

### 重要澄清

**服务器公钥的来源：**
- 服务器公钥**嵌入在服务器的数字证书中**
- 客户端通过验证证书的有效性来确认公钥的真实性
- 这是HTTPS安全性的核心：通过CA认证确保公钥确实属于目标服务器
- 客户端绝不能直接信任明文传输的公钥，必须通过证书验证

### 预主密钥的核心作用

**预主密钥（Pre-Master Secret）是TLS握手中的关键中间密钥：**

1. **密钥协商的结果**
   - 在RSA密钥交换中：客户端随机生成48字节的预主密钥
   - 在ECDHE密钥交换中：通过椭圆曲线Diffie-Hellman计算得出

2. **会话密钥的原材料**
   - 预主密钥本身不直接用于加密通信
   - 而是作为输入，通过密钥派生函数生成真正的会话密钥

3. **密钥派生过程**
   ```
   预主密钥 + 客户端随机数 + 服务端随机数
         ↓ 通过PRF函数
   主密钥（Master Secret）
         ↓ 继续派生
   各种会话密钥（加密密钥、MAC密钥等）
   ```

4. **安全特性**
   - **前向安全性**：即使预主密钥泄露，由于包含随机数，仍难以推导出会话密钥
   - **唯一性**：每次连接的预主密钥都不同，确保会话隔离
   - **机密性**：通过服务器公钥加密传输，只有持有对应私钥的服务端能解密

**为什么需要预主密钥这个中间步骤？**
- 提供统一的密钥材料来源，无论使用哪种密钥交换算法
- 结合随机数确保每次会话的密钥都是唯一的
- 通过层次化的密钥派生增强安全性


# TCP 与 UDP 的 10 大核心区别是什么？

## 我的回答
1.传输协议上，TCP适用于可靠传输，UDP适用于不可靠传输
2.TCP适用于安全的稳定短连接，UDP适用于视频等不稳定的长连接
3.TCP基于字节流，UDP基于报文
。。。。不会了

##  标准答案

1.连接性
TCP:三次握手与四次挥手
UDP:直接发报文

2.可靠性：
TCP:可靠，ACK机制，数据有序不丢失，数据丢失会重传
UDP:不可靠，数据无序，可能会丢失

3.传输粒度：
TCP:字节流
UDP:报文

4.流量拥塞控制：
TCP:有窗口加拥塞算法
UDP:无

5.传输速度：
TCP:慢
UDP:快、延迟小

6.组播/广播：
TCP：不支持
UDP:单播/组播/广播   关于组播的解释：把数据从一个数据源发送到一组特定的数据源

7.使用场景：
TCP:HTTP/HTTPS 数据库 FTP 邮件
UDP:DNS 视频、会议、优秀

8.成本：
TCP:资源占用高
UDP:资源占用低

9.消息边界：
TCP:无消息边界
UDP:有消息边界

10.首部开销：
TCP:20+Byte
UDP:8Byte

# 说说 TCP 的三次握手

## 我的回答 6

客户端向服务端发送了一个asyn同步请求，请求建立连接。
服务端收到请求，并返回了一个ack确认帧。
然后服务端向客户端发送了一个asyn请求，请求建立服务端到客户端的连接。

客户端收到服务端的返回，返回一个ack确认帧，三次握手结束

## 标准答案

第一次握手:
客户端向服务端发送一个syn同步请求，seq=x,进入syn_sent状态
第二次握手：
服务端接收到客户端的请求，返回syn=y+ack=x+1。进入syn_receive状态

第三次握手：
客户端收到服务端的返回，返回一个ack=y+1确认帧，三次握手结束

# TCP 协议如何保证可靠传输？

## 我的回答：6
ack确认重传机制，如果在传输过程中，没有收到报文的ack确认帧，则会自动重传保证信息的完整

流量控制机制：
TCP有滑动窗口和拥塞控制算法，通过动态调整发送窗口和接收窗口保证稳定的传输

## 标准答案

1.字节流分段与序列号：
 TCP将应用层数据看作无限长的字节流， 发送前按MTU分段，并为每一个字节分配序列号。每个报文段报头包含起始字节序号和报文段长度，接收方根据这个进行重排序、丢包检测等

2.校验和:
每个TCP首部都有16位校验和，覆盖TCP首部、数据、伪首部（Ip源/目的，协议、长度）

3.累积确认与超时重传：
 1.累计确认：
 接收方回复ack=n,表示已经收到了所有序列号小于n-1的字节
 若某包丢失或乱序，接收方只能确认到最远的连续的序号，可以根据这个来判断哪里丢失
 2.超时重传：
 发送方为每一个每个未确认的数据启动重传计时器
 若超时没有收到该数据的ack,重传数据并启动指数退避

4.滑动窗口和流量控制:
滑动窗口：让发送方在未收到确认之前可以发送多个数据包，窗口大小由接收方的接收窗口大小决定。以提高效率
流量控制：接收窗口根据接收的流量，动态调整我们的接收窗口

5.拥塞控制：
慢启动：从小拥塞窗口开始，每接收一个ack,拥塞窗口大小翻倍
拥塞避免：窗口大小达到阈值以后，线性增长，每接收一个ack，窗口大小增加1
快恢复：收到三个重复ack,进入快恢复模式，阈值大小变为原来一半，窗口变为1








